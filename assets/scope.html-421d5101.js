import{_ as n,p as s,q as a,a1 as e}from"./framework-cd43f88a.js";const o="/blog/assets/scope_1.drawio-07f27a0b.svg",t="/blog/assets/scope_2.drawio-242958c5.svg",c="/blog/assets/scope_3.drawio-429d86ce.svg",p={},i=e(`<h1 id="scope-chain-scope" tabindex="-1"><a class="header-anchor" href="#scope-chain-scope" aria-hidden="true">#</a> Scope Chain &amp; Scope</h1><h2 id="scope-chain" tabindex="-1"><a class="header-anchor" href="#scope-chain" aria-hidden="true">#</a> Scope chain</h2><p>Scope chain 是當前 EC 的 Reference 所關聯到的外部 EC 去尋找的，而外部的 EC 也有自己的 Ref 參照到更外面，這樣不斷的往外參照直到 global，就形成了一條 scope chain。</p><p>要特別強調，Reference 向外的關聯並不是關聯到 call stack 中的前一個 EC，而是關聯到「創建當前 EC」的 EC，換個說法就是 Reference 關聯哪一個 EC 看的不是當前 EC 由誰呼叫，而是看當前 EC 被誰創建的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span>
<span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">&#39;global text&#39;</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">&#39;a text&#39;</span>

  <span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中：</p><ol><li><p>Global EC 創建階段將 <code>num</code>、<code>text</code>、<code>a function</code>、<code>c function</code> 存儲到記憶體中，並在執行階段賦值(assign)了 <code>num</code>&amp;<code>text</code> 後執行<code>a()</code></p><p>current stack: [global, a()]</p></li><li><p>此時 <code>a-EC</code> 被放入 stack 中，<code>a-EC</code> 的創建階段將<code>text</code>、<code>b function</code> 存儲到記憶體中，並在執行階段 assign <code>text</code> 後執行 <code>b()</code></p><p>current stack: [global, a(), b()]</p></li><li><p><code>b-EC</code> 被放入 stack 中，<code>b-EC</code> 的執行階段執行了 <code>c()</code></p><p>current stack: [global, a(), b(), c()]</p></li><li><p>接著繼續執行 <code>c()</code>，並且將<code>c-EC</code>放入 stack</p><p>current stack: [global, a(), b(), c()]</p></li><li><p><code>c-EC</code> 執行 log(text)，但<code>c-EC</code>中沒有 text，因此沿著 REF 找，這時雖然 stack 中 <code>c-EC</code> 的上一層是 <code>b-EC</code>，但 <code>c function</code> 是由 global 創建的，所以 REF 指向 global，text 也會往 global 尋找，最後印出<code>&#39;global text&#39;</code>，而非印出呼叫 <code>c()</code> 時外部的 <code>&#39;a text&#39;</code></p></li></ol><h2 id="scope" tabindex="-1"><a class="header-anchor" href="#scope" aria-hidden="true">#</a> Scope</h2><p>ES6 之後 Scope 有三種 - <code>Global scope</code>、<code>Function scope</code>、<code>Block scope</code>，其中 <code>Block scope</code> 是隨著 ES6 的 <code>let</code>、<code>const</code> 所新增的。 相信大家都知道 <code>var</code> 跟 <code>let</code>、<code>const</code> 在作用域上有不同的表現：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> textVar <span class="token operator">=</span> <span class="token string">&#39;origin var&#39;</span>
<span class="token keyword">let</span> textLet <span class="token operator">=</span> <span class="token string">&#39;origin let&#39;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> textVar <span class="token operator">=</span> <span class="token string">&#39;new var&#39;</span>
  <span class="token keyword">let</span> textLet <span class="token operator">=</span> <span class="token string">&#39;new let&#39;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>textVar<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>textLet<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span> <span class="token comment">// new var, origin let</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中我們在 block scope 中重複宣告了 <code>var</code> &amp; <code>let</code>，最終 <code>var</code> 被重新賦值但 <code>let</code> 依然是 &#39;origin let&#39;，表面上我們知道 <code>var</code> 不受 Block Scope 所限制，實際上發生了什麼事？</p><p>首先 Global EC 被放入 stack 中，開始創建階段，直到<code>第二行</code>時，JS Engine 將 <code>textVar</code> &amp; <code>textLet</code> 塞進記憶體中，但此時 <code>textVar</code> 被存在 <code>Variable Environment</code>，而 <code>textLet</code> 被存在 <code>textLet</code>。</p><p>接著繼續在創建階段的<code>第四行</code>，因為 scope 是不會產生新 EC 的，因此無論 if 條件判斷如何，scope 中的變數一樣會在創建階段被存入記憶體之中。</p><p>創建階段的<code>第五行</code>，<code>textVar</code> 被重新宣告並且初始化賦予 <code>undefined</code>，注意此時 <code>Variable env.</code> 中只存有一個變數叫 textVar</p><svg width="600" height="400" xmlns="http://www.w3.org/2000/svg"><image href="`+o+'" height="400" width="600"></image></svg><p>創建階段的<code>第六行</code>，又宣告同名的 <code>textLet</code>，此時「因為在 block scope 中宣告」，因此 Lexical env. 為其創建這個 block scope 專屬的環境</p><svg width="600" height="400" xmlns="http://www.w3.org/2000/svg"><image href="'+t+`" height="400" width="600"></image></svg><p>所以到了執行階段，<code>var</code> 會被更新，但 <code>let</code> 卻能保持原有的值，<strong>雖然在同一個 EC 中</strong>，但 <code>let</code> 遇到 block scope 時會在 Lexical env. 中創建其專屬的作用域</p><p>最後按照這個邏輯，我們回頭看面試經典題目：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 3, 3, 3</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 0, 1, 2</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>這裡先不談 event loop，光看 scope 我們可以知道：var 從頭到尾都只有一個，但 let 在 for loop 循環中依序創建了三個專屬的 scope，所以回頭查找參照的變數時才能夠找到對應的 let，不像 var 會被覆蓋。</p><svg width="600" height="400" xmlns="http://www.w3.org/2000/svg"><image href="`+c+'" height="400" width="600"></image></svg>',22),l=[i];function d(u,r){return s(),a("div",null,l)}const v=n(p,[["render",d],["__file","scope.html.vue"]]);export{v as default};
