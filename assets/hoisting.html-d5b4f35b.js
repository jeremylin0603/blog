import{_ as c,M as o,p as i,q as p,Q as n,t as s,N as e,V as d,a1 as l}from"./framework-cd43f88a.js";const r={},u=n("h1",{id:"hoisting",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#hoisting","aria-hidden":"true"},"#"),s(" Hoisting")],-1),m=l(`<p>hoist:「提升」，這不是個好名字，因為實際上沒有任何程式碼被「提升」，會讓不知道的人以為自己懂了但其實誤會大了(像是當年剛接觸 JS 的我 QQ)</p><p>要了解 Hoisting，得先知道 JS 運行時並不是一開始就馬上一行一行的跑我們寫的程式碼，而是在這之前先做了一些「準備」，做完「準備」才會開始從頭「執行」我們的 code。</p><p>而「準備」階段，會先從頭找出在當前的作用域中，所有宣告的變數(var, let, const)和方法(function)，並且為他們在記憶體中預先創建這些變數和方法的空間。</p><p>也因此我們能夠在宣告變數或方法之前呼叫他們而不會報錯(let, const 例外，後面會提)，感覺起來就像他們被「提升」到檔案頂端了。</p><p>接著來看一個例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// hi!</span>

<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi!&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>第1行</code>在 <code>num</code> 宣告之前存取了 <code>num</code>，沒有報錯並且得到 <code>undefined</code> 而不是 <code>1</code>，接著<code>第2行</code>在 fn 宣告之前執行了 fn，也執行成功 log 出 <code>&#39;hi!&#39;</code>，為什麼 <code>num</code> 不是 <code>1</code>，但 fn 可以正常運行？</p><p>首先要了解 <code>=</code> 賦值(assigned)運算子跟 <code>+</code>、<code>-</code> 一樣，都是「準備完畢」之後的「執行」階段才會作用，執行時才會將<code>=</code>右側(Right side)的值賦予左側(Left side)的變數。</p><p>而在「準備」階段 JS 會替 <code>var</code>、<code>let</code>、<code>const</code> 宣告的變數建立一個專屬的記憶體空間，並且將 <code>var</code>「初始化」(initialize)賦與 <code>undefined</code>(只有<code>var</code>會被初始化賦予<code>undefined</code>)。</p><p>因此在 <code>=</code> 被執行前，若我們要存取 <code>var</code> 所宣告的變數，則會是初始化階段賦予的 <code>undefined</code>，直到 <code>=</code> 運算子被執行。</p><p>至於 function 在「準備」階段就會直接被存入記憶體中，所以可以順利呼叫並執行，<strong>但這是很糟糕的 coding style，千萬別在專案中做這種事。</strong></p><p>接著看<code>let</code>&amp;<code>const</code>的例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// &quot;Cannot access &#39;num&#39; before initialization&quot;</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">ACCESS_TOKEN</span><span class="token punctuation">)</span> <span class="token comment">// &quot;Cannot access &#39;ACCESS_TOKEN&#39; before initialization&quot;</span>
<span class="token keyword">const</span> <span class="token constant">ACCESS_TOKEN</span> <span class="token operator">=</span> <span class="token string">&#39;abcde&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>範例中我們試著在 <code>let</code>、<code>const</code> 宣告之前存取，但是報錯了，所以<code>let</code>、<code>const</code>就沒有 hoisting 嗎？</p><h4 id="let、const依然有-hoisting" tabindex="-1"><a class="header-anchor" href="#let、const依然有-hoisting" aria-hidden="true">#</a> <code>let</code>、<code>const</code>依然有 hoisting</h4><p>這是很常見的思維誤區，首先按照 hoisting 的原因（在「準備」時預先創建變數的空間並將變數指向該空間），<code>let</code>、<code>const</code>也沒有例外地創建了專屬的記憶體空間，<strong>只是因為沒有初始化，JS 不讓讀取而已</strong>，我們可以從 error message 窺探一二：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// &quot;Cannot access &#39;num&#39; before initialization&quot;</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// &quot;num is not defined&quot;</span>
<span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&#39;hi!&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一個例子一樣先在宣告前存取<code>num</code>，沒有意外地報錯。</p><p>但在第二個例子中，若我們 log 一個不曾宣告的變數，則會報錯 <strong>num is not defined</strong>，訊息中告訴我們 <code>num</code> 並沒有被定義。</p><p>回到第一個例子的錯誤訊息： <strong>Cannot access &#39;num&#39; before initialization</strong>，表示 JS 「知道」你有定義變數，但是「初始化之前」不允許你存儲這個變數。</p><h4 id="暫時性死區-temporal-dead-zone-tdz" tabindex="-1"><a class="header-anchor" href="#暫時性死區-temporal-dead-zone-tdz" aria-hidden="true">#</a> 暫時性死區 Temporal Dead Zone(TDZ)</h4><p>由於 <code>let</code> &amp; <code>const</code> 依然有 hoisting，只是在初始化之前無法存取，這個宣告前無法存取的地方被稱為<strong>暫時性死區</strong> <strong>Temporal Dead Zone(TDZ)</strong></p><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h2><p>總之，我們只需要知道 JS 在處理檔案的過程中，會有兩個階段「準備」與「執行」，而「準備」階段會先掃過當前作用域中宣告的所有變數和方法，並且預先在記憶體中創建他們的空間，這個先「準備」的過程就是 hoisting，別想得太複雜。</p><p>至於知道這個有什麼用？<s>因為面試會考啊</s>從底層認識 JS，我們才能知道一些 bug 「根本」的原因出在哪裡，而不是靠著模糊的概念瞎 G8 亂猜，就算運氣好猜對了修好 bug，其實你以為的原因也是錯的，這也是觀察到工程師之間一條很明顯的分水嶺，如果我們面對所有現象都只用模糊的概念去理解，那這世界最後就只會有宗教，不會有科學了。</p><p>所以面試會考是有它的道理在的。</p><h2 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> REF</h2>`,29),v={href:"https://dev.to/pranav016/advanced-javascript-series-part-42-scope-chains-and-their-working-lexical-and-variable-environments-19d5",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.udemy.com/course/javascriptjs/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://medium.com/itsems-frontend/javascript-scope-and-scope-chain-ca17a1068c96",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.w3schools.com/js/js_scope.asp",target:"_blank",rel:"noopener noreferrer"};function f(b,_){const t=o("RouterLink"),a=o("ExternalLinkIcon");return i(),p("div",null,[u,n("blockquote",null,[n("p",null,[s("本篇會專注在方便理解 Hoisting，更詳細的運行邏輯請往"),e(t,{to:"/code-memo/js-we-dont-know/execution-context.html"},{default:d(()=>[s("Execution context")]),_:1})])]),m,n("p",null,[n("a",v,[s("What is a Scope Chain?"),e(a)]),s(" @DEV Community")]),n("p",null,[n("a",k,[s("JavaScript 全攻略：克服 JS 的奇怪部分"),e(a)]),s(" @Udemy")]),n("p",null,[n("a",h,[s("Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找"),e(a)]),s(" @medium")]),n("p",null,[n("a",g,[s("Javascript Scope"),e(a)]),s(" @W3C")])])}const j=c(r,[["render",f],["__file","hoisting.html.vue"]]);export{j as default};
